# Introducción a Ciencia de Datos

## ¿Qué es Ciencia de Datos?

### Definiendo conceptos: 

**Estadistica** Disciplina que recolecta, organiza, analiza e interpreta datos. Lo hace a través de una población muestral generando estadística descriptiva y estadística inferencial.

  * Estadística descriptiva: Describe de manera cuantificada información de los datos: distribuciones de los datos, análisis exploratorio, correlaciones, outliers, etc.
  * Estadística inferencial: A partir de los datos de una población muestral, deducir / concluir / analizar hipótesis para una población.
  * Principales tipos de problemas: Todo lo que tenga datos - tener muchos datos, puede llegar a ser un problema -.
  * La estadística supone *casi siempre* que el sistema es estático y generaliza la solución bajo las mismas condiciones.
  * Si la cantidad de datos es de "gran escala", es muy probable que se tengan que hacer muestras para trabajar con los datos.
  
```{r echo=FALSE,fig.align='center'}
knitr::include_graphics("img/01-intro/01_muestra.jpg")
```

- **Business Intelligence**: BI aprovecha el software y los servicios para transformar los datos en conocimientos prácticos que informan las decisiones empresariales estratégicas y tácticas de una organización. Las herramientas de BI acceden y analizan conjuntos de datos y presentan hallazgos analíticos en informes, resúmenes, tableros, gráficos, cuadros, -indicadores- o KPI's y mapas para proporcionar a los usuarios inteligencia detallada sobre el estado del negocio. (BI esta enfocado en analizar la historia pasada)

```{r echo=FALSE,fig.align='center'}
knitr::include_graphics("img/01-intro/04_bi.png")
```


- **Machine Learning**: El ‘machine learning’ –aprendizaje automático– es una rama de la inteligencia artificial que permite que las máquinas aprendan de los patrones existentes en los datos. Se usan métodos computacionales para aprender de datos con el fin de producir reglas para mejorar el desempeño en alguna tarea o toma de decisión. (Está enfocado en la programación de máquinas para aprender de los patrones existentes en datos principalmente estructurados y anticiparse al futuro)

```{r echo=FALSE,fig.align='center', out.width='600pt'}
knitr::include_graphics("img/01-intro/02_ml.png")
```


```{r echo=FALSE,fig.align='center'}
knitr::include_graphics("img/01-intro/03_supervisado_robo.png")
```



- **Deep Learning**: El aprendizaje profundo es un subcampo del aprendizaje automático que se ocupa de los algoritmos inspirados en la estructura y función del cerebro llamados redes neuronales artificiales. 

  En *Deep Learning*, un modelo de computadora aprende a realizar tareas de clasificación directamente a partir de imágenes, texto o sonido. Los modelos de aprendizaje profundo pueden lograr una precisión de vanguardia, a veces superando el rendimiento a nivel humano. Los modelos se entrenan mediante el uso de un gran conjunto de datos etiquetados y arquitecturas de redes neuronales que contienen muchas capas. (Está enfocado en la programación de máquinas para el reconocimiento de imagenes y audio (datos no estructurados))
  
```{r echo=FALSE,fig.align='center'}
knitr::include_graphics("img/01-intro/05_reconocimiento.png")
```
  
```{r echo=FALSE,fig.align='center'}
knitr::include_graphics("img/01-intro/06_ml1.png")
```
  
- **Big data** se refiere a los grandes y diversos conjuntos de información que crecen a un ritmo cada vez mayor. Abarca el volumen de información, la velocidad a la que se crea y recopila, y la variedad o alcance de los puntos de datos que se cubren. Los macrodatos a menudo provienen de la minería de datos y llegan en múltiples formatos.

  Es comun que se confunda los conceptos de *Big Data* y *Big Compute*, como habiamos mencionado *Big Data* se refiere a el procesamiento de conjuntos de datos que son más voluminosos y complejos que los tradicionales y *Big Compute* a herramientas y enfoques que utilizan una gran cantidad de recursos de CPU y memoria de forma coordinada para resolver problemas que usan algoritmos muy complejos.

```{r echo=FALSE,fig.align='center', out.width='600pt'}
knitr::include_graphics("img/01-intro/07_bigdata.jpg")
```

Curiosidad: [Servidores en líquido para ser enfriados](https://www.xatakawindows.com/actualidad-en-redmond/servidores-liquido-hirviendo-esta-idea-microsoft-para-evitar-calentamiento-sus-equipos#:~:text=Con%20este%20sistema%2C%20el%20dispositivo,fr%C3%ADo%2C%20emplea%20uno%20en%20ebullici%C3%B3n.)

Curiosidad 2: [Centro de datos en el océano](https://www.bbc.com/mundo/noticias/2016/02/160202_microsoft_centro_datos_debajo_agua_mar_subamino_all)


</br>
**Entonces, ¿qué NO es ciencia de datos?**

- No es una tecnología
- No es una herramienta
- No es desarrollo de software
- No es Business Intelligence*
- No es Big Data*
- No es Inteligencia Artificial*
- No es (solo) machine learning
- No es (solo) deep learning
- No es (solo) visualización
- No es (solo) hacer modelos

## Objetivo de la Ciencia de Datos

- **Ciencia de datos**: Los científicos de datos analizan qué preguntas necesitan respuesta y dónde encontrar los datos relacionados. Tienen conocimiento de negocio y habilidades analíticas, así como la capacidad de extraer, limpiar y presentar datos. Las empresas utilizan científicos de datos para obtener, administrar y analizar grandes cantidades de datos no estructurados. Luego, los resultados se sintetizan y comunican a las partes interesadas clave para impulsar la toma de decisiones estratégicas en la organización.


```{r echo=FALSE,fig.align='center', out.height='500pt', out.width='600pt'}
knitr::include_graphics("img/01-intro/08_data_science_vd.png")
```
Fuente: [Blog post de Drew Conway](http://drewconway.com/zia/2013/3/26/the-data-science-venn-diagram)

Más sobre Conway: [Forbes 2016](https://www.forbes.com/sites/joshwolfe/2016/03/03/using-data-science-for-the-physical-world/?sh=614ac5b0150e)


## ¿Qué se requiere para hacer Ciencia de Datos?

- Background científico
  
  - Conocimientos generales de probabilidad, estadística, álgebra lineal, cálculo, geometría análitica, programación, conocimientos computacionales... etc  

- Datos

  - Relevancia y suficiencia
  
  Es indispensable saber si los datos con los que se trabajará son relevantes y suficientes, debemos evaluar qué preguntas podemos responder con los datos con los que contamos.
  
  - Suficiencia: Los datos con los que trabajamos tienen que ser representativos de la población en general, necesitamos que las características representadas en la información sean suficientes para aproximar a la población objetivo. 
      
  - Relevancia: De igual manera los datos tienen que tener relevancia para la tarea que queremos resolver, por ejemplo, es probable que información sobre gusto en alimentos sea irrelevante para predecir número de hijos.

```{r echo=FALSE,fig.align='center'}
knitr::include_graphics("img/01-intro/09_relevancia_suficiencia.png")
```

- Etiquetas

    - Se necesita la intervención humana para etiquetar, clasificar e introducir los datos en el algoritmo.
    
    
```{r echo=FALSE,fig.align='center', out.height='300pt', out.width='600pt'}
knitr::include_graphics("img/01-intro/10_etiquetas.png")
```


- Software

    - Existen distintos lenguajes de programación para realizar ciencia de datos:

```{r echo=FALSE,fig.align='center', out.height='300pt', out.width='600pt'}
knitr::include_graphics("img/01-intro/11_lenguajes.png")
```

## Aplicaciones de Ciencia de Datos

Dependiendo de la industria en la que se quiera aplicar Machine Learning, podemos pensar en distintos enfoques, en la siguiente imagen se muestran algunos ejemplos:

```{r echo=FALSE, fig.align='center', out.height='750pt', out.width='800pt'}
knitr::include_graphics("img/01-intro/12_aplicaciones.jpg")
```

Podemos pensar en una infinidad de aplicaciones comerciales basadas en el análisis de datos. Con la intención de estructurar las posibles aplicaciones, se ofrece a contiuación una categorización que, aunque no es suficiente para englobar todos los posibles casos de uso, sí es sorprendente la cantidad de aplicaciones que abarca.

**1. Aplicaciones centradas en los clientes**

 * Incrementar beneficio al mejorar recomendaciones de productos
 * Upselling
 * Cross-selling
 * Reducir tasas de cancelación y mejorar tasas de retención
 * Personalizar experiencia de usuario
 * Mejorar el marketing dirigido
 * Análisis de sentimientos
 * Personalización de productos o servicios

**2. Optimización de problemas**

 * Optimización de precios
 * Ubicación de nuevas sucursales
 * Maximización de ganancias mediante producción de materias primas
 * Construcción de portafolios de inversión

**3. Predicción de demanda**

 * Número futuro de clientes
 * Número esperado de viajes en avión / camión / bicis
 * Número de contagios por un virus (demanda médica / medicamentos / etc)
 * Predicción de uso de recursos (luz / agua / gas)

**4. Análisis de detección de fraudes**

 * Detección de robo de identidad
 * Detección de transacciones ilícitas
 * Detección de servicios fraudulentos
 * Detección de zonas geográficas con actividades ilícitas

##  Tipos de aprendizaje

La diferencia entre el análisis supervisado y el no supervisado es la etiqueta, es decir, en el análisis supervisado tenemos una etiqueta "correcta" y el objetivo de los algoritmos es predecir esta etiqueta.

### Aprendizaje supervisado

- Conocemos la respuesta correcta de antemano.

- Esta respuesta correcta fue "etiquetada" por un humano (la mayoría de las veces, en algunas circunstancias puede ser generada por otro algoritmo).

- Debido a que conocemos la respuesta correcta, existen muchas métricas de desempeño del modelo para verificar que nuestro algoritmo está haciendo las cosas "bien".


#### Tipos de aprendizaje supervisado (Regresión vs clasificación)

Existen dos tipos principales de aprendizaje supervisado, esto depende del tipo de la variable respuesta:

- Los algoritmos de **clasificación** se usan cuando el resultado deseado es una etiqueta discreta, es decir, clasifican un elemento dentro de diversas clases.

- En un problema de **regresión**, la variable target o variable a predecir es un valor numérico.

<br/>

```{r echo=FALSE,fig.align='center', out.height='450pt', out.width='700pt'}
knitr::include_graphics("img/01-intro/13_regresion_clasificacion.png")
```


### Aprendizaje no supervisado

- Aquí no tenemos la respuesta correcta de antemano ¿cómo podemos saber que el algoritmo está bien o mal?

- Estadísticamente podemos verificar que el algoritmo está bien

- Siempre tenemos que verificar con el cliente si los resultados que estamos obteniendo tienen sentido de negocio. Por ejemplo, número de grupos y características


```{r echo=FALSE,fig.align='center'}
knitr::include_graphics("img/01-intro/14_nosupervisado_robo.png")
```

## ¿Qué es *R*?

R (R Core Team 2018) es un entorno y lenguaje de programación que permite el análisis estadístico de información y reportes gráficos. Es ampliamente usado en investigación por la comunidad estadística en campos como la biomedicina, minería de datos, matemáticas financieras, entre otros. Ha ganado mucha popularidad en los últimos años al ser un software libre que está en constante crecimiento por las aportaciones de otros usuarios y que permite la interacción con software estadísticos como STATA, SAS, SPSS, etc.. R permite la incorporación de librerías y paqueterías con funcionalidades específicas, por lo que es un lenguaje de programación muy completo y fácil de usar.


## ¿Cómo obtener *R*?

R puede ser fácilmente descargado de forma gratuita desde el sitio oficial [http://www.r-project.org/](http://www.r-project.org/). R está disponible para las plataformas Windows, Mac y Linux.


## ¿Qué es RStudio?

*RStudio* es un Entorno de Desarrollo Integrado (IDE, por sus siglas en inglés) para R. Este permite y facilita el desarrollo y ejecución de sintaxis para código en *R*, incluye una consola y proporciona herramientas para la gestión del espacio de trabajo. *RStudio* está disponible para Windows, Mac y Linux o para navegadores conectados a RStudio Server o RStudio Server Pro.

Algunas de las principales características de Rstudio que lo hacen una gran herramienta para trabajar en R, son:

+ Auto completado de código
+ Sangría inteligente
+ Resaltado de sintaxis
+ Facilidad para definir funciones
+ Soporte integrado
+ Documentación integrada
+ Administración de directorios y proyectos
+ Visor de datos
+ Depurador interactivo para corregir errores
+ Conección con Rmarkwon y Sweave

La siguiente imagen muestra la forma en la que está estructurado RStudio. El orden de los páneles puede ser elegido por el usuario, así como las características de tipo de letra, tamaño y color de fondo, entre otras características.

```{r, echo = F, out.width = "800px", out.height="450px", fig.align = "center", fig.cap= "Páneles de trabajo de Rstudio"}
knitr::include_graphics("img/01-intro/15_rstudio3.png")
```

## *R* como lenguaje orientado a objetos

*R* es un lenguaje de programación orientado a objetos (POO). (López 2011, pag. 5) define a los objetos y sus características como “cualquier cosa con significado para el problema que se trata de resolver”. A partir de esa definición, se puede decir que sirve para representar alguna entidad de la vida real, por lo general son componentes del problema que se pretende resolver y con los que podemos interactuar. A través de esta interacción y del estudio que se haga de ellos, es posible clasificarlos en grupos de acuerdo a sus caractrerísticas. A partir de los objetos con los que se trabaje, surgirán las clases adecuadas para encontrar la solución a un problema dado.

Los objetos tienen características fundamentales que permiten identificarlos, conocerlos y entender su comportamiento. De acuerdo con (Schildt 2009), estas características son:

1. Identidad
2. Comportamiento
3. Estructura

* **Identidad:** Esta es la propiedad que da nombre a cada uno de los objetos y que permite declararlos, distinguirlos de manera única, usarlos y llamarlos para la representación de su contenido.

* **Comportamiento:** Esta es la propiedad que determina las operaciones que puede realizar el objeto, es decir, permite conocer las capacidades y alcances de la funcionalidad de cada objeto. El comportamiento permite conocer la interacción que puede existir con otros objetos y los resultrados que generarán.

* **Estructura:** El estado se refiere a un conjunto de características o atributos específicos del objeto dados en un momento determinado, y que pueden cambiar en un instante de tiempo.

En la programación orientada a objetos, un programa recolecta muchos objetos para ser tratado como un conjunto dinámico de objetos interactuando entre sí. Los objetos están definidos por:

1. **Atributos:** Son las propiedades o características de los datos contenidos en un objeto. Los valores asociados a un objeto en un momento determinado del tiempo determinan su estado.

2. **Métodos:** Acceden a los atributos de los objetos y determinan el comportamiento de los datos contenidos.

### Clases

R posee 5 clases de objetos básicas o atómicas integradas. A partir de la combinación de ellas, se construyen todas las demás. Estas clases atómicas son:

1. Character (caracteres)
2. Numeric (números reales)
3. Integer (números enteros)
4. Complex (números complejos)
5. Logical (valores lógicos verdadero y falso)

En R, todo es un objeto, por lo que es posible acceder a sus características a través de funciones predefinidas en la librería básica. Por ejemplo:

```{R}
class("Hola mundo")

class(10.5)

class(integer(10))

class(10 + 1i)

class(TRUE)
```

### Creación de objetos

Los objetos pueden ser guardados a través del operador '<-' ó '=', anteponiendo al operador un nombre que servirá como el identificador del objeto:

```{R}
Mi_primer_objeto <- 10
Nombre_identificador <- "Objeto de clase caracter"
```

Es posible acceder al contenido de un objeto al mandarlo llamar mediante su identificador, esto se logra escribiendo en la consola la función 'print()', incluyendo entre paréntesis el nombre del objeto a imprimir, o bien, escribiendo en la consola directamente el nombre del objeto y automáticamente imprimirá su contenido, como se ve a continuación:

```{R}
print(Mi_primer_objeto)

Nombre_identificador
```

Para almacenar conjuntos de datos en R, es posible hacerlo de distintas formas, la más básica y sencilla es a través de un vector. Utilizando la función 'c()' e introduciendo los objetos a almacenar separándolos por comas entre sí. La característica fundamental de los vectores es que almacenan información de la misma clase. A continuación se muestran dos ejemplos con distinta clase cada uno.

```{R}
vector_numerico <- c(1,2,3,4,5,6)
print(vector_numerico)

vector_caracter <- c("este", "es", "un", "vector", "de", "caracteres")
print(vector_caracter)
```

En caso de que se introduzcan objetos de diferentes clases, R convertirá la clase de los objetos de tal forma que todos puedan ser representados por la misma clase, por ejemplo:

```{R}
c(1,2,3,4,"cinco")    # Los números son representados como caracteres

c(TRUE, 2, FALSE)     # True y False se convierten en los números 1 y 0 respectivamente

c(TRUE, F, 1, "dos")  # Todos los objetos son convertidos a caracteres
```

Para acceder al i-ésimo elemento de un vector se usa un índice que determina su posición exacta dentro del vector. Este índice debe incluirse entre corchetes inmediatamente después del nombre del vector. Hay que tomar en cuenta que, a diferencia de otros lenguajes de programación, en R la numeración de los índices comienza desde 1, por lo que si se desea acceder al cuarto elemento o al conjunto de elementos 1,4,5,6, se deberá escribir de la siguiente forma:

```{R}
vector_caracter[4]

vector_caracter[c(1,4,5,6)]
```

En caso de que se desee almacenar elementos con diferente tipo de clase, es posible hacerlo mediante la implementación de "listas". Las listas dividen en secciones los elementos de diferentes clases. Para poder acceder a dichas secciones, se usa el nombre de la sección o índice entre doble corchete. Por ejemplo:

```{R}
Mi_lista <- list()
Mi_lista[[1]] <- c(1,2,3,4,5)
Mi_lista[['Segunda entrada']] <- c(T,T,F,T,F,F)
Mi_lista[[3]] <- c('Hay', 3, 'objetos almacenados')
print(Mi_lista)
```

Para acceder a la j-ésima sección, se debe especificar entre doble corchete el índice o nombre de la sección deseada. Si se desea acceder al i-ésimo elemento de la j-ésima sección, deberá ser especificada la sección y posteriormente el i-ésimo elemnto a extraer.

```{R}
Mi_lista[[1]]           # Extracción completa de la primera sección.

Mi_lista[[1]][3]        # Extracción del tercer elemento de la primera sección.

Mi_lista[[2]][c(2,3,4)] # Extracción de los elemntos 2,3 y 4 de la segunda sección.

Mi_lista[[3]][3]
```

Para almacenar grandes conjuntos de información conformados por distintos vectores, es común recurrir a los objetos de la clase 'data.frame'. La estructura de dichos objectos está conformada por dos dimensiones (renglones y columnas). Dicha estructura se usa principalmente para capturar diferentes características de sujetos o elementos, los renglones son las observaciones o los distintos sujetos y las columnas se usan para capturar cada una de las características del sujeto u observación.

Esta estructura suele ser trabajada de dos formas principales, la primera es construyéndose desde dentro del código conforme se va generando la información, ó bien la segunda, leyendo datos de manera externa.
El primer método requiere de la concatenación de 2 o más vectores de la misma dimensión. Los elementos a concatenar se pasan como parámetros de la función cbind.data.frame() ó rbind.data.frame(), dependiendo de si se desean concatenar como renglones o como columnas. A continuación se verá un ejemplo:

```{R}
vector1<- c("a","b","c","d","e")
vector2<- c(1,2,3,4,5)
vector3<- c(T,F,T,F,T)

dataframe1<-cbind.data.frame(vector1,vector2,vector3)
colnames(dataframe1)<- c("Columna 1","Columna 2","Columna 3")
dataframe1

class(dataframe1)

dataframe2 <-rbind.data.frame(vector1,vector2,vector3)
colnames(dataframe2)<-c("Columna 1","Columna 2","Columna 3", "Columna 4","Columna 5")
dataframe2

class(dataframe2)

```