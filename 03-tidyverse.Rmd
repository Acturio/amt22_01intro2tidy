# Tidyverse

## Consultas de datos (dplyr)

Ahora que ya sabemos como cargar datos, aprenderemos como manipularlos con *dplyr.* El paquete *dplyr* proporciona un conjunto de funciones muy útiles para manipular data frames y así reducir el número de repeticiones, la probabilidad de cometer errores y el número de caracteres que hay que escribir. Como valor extra, podemos encontrar que la gramática de *dplyr* es más fácil de entender.

Revisaremos algunas de sus funciones **más usadas** (*verbos*), así como el uso de **pipes** (%>%) para combinarlas.

- select()

- filter()

- arrange()

- mutate()

- summarise()

- join()

- group_by()

Primero tenemos que instalar y cargar la paquetería (parte de tidyverse):

```{r,eval=TRUE}
# install.packages("dplyr")
library(dplyr)
```

Usaremos el dataset *iris* que se encuentra en la paquetería *datasets* (el alumno puede hacer el ejercicio con la base AmesHousing)

```{r}
head(iris,10)
```


### select()

Observamos que nuestros datos tienen 150 observaciones y 5 variables, con *select()* podemos seleccionar las variables que le indiquemos.

```{r}
select_ejemplo<-iris %>% select(Sepal.Length,Petal.Length,Species)
head(select_ejemplo,10)
```

El operador pipe (%>%) se usa para conectar múltiples acciones, en este caso solo le indicamos que en los datos de iris se seleccionan 3 varibles y se guarda este nuevo data frame en la variable *select_ejemplo*.



Con *select()* y *contains* podemos seleccionar varibles con alguna cadena de texto. 

```{r}
select_ejemplo<-iris %>% select(contains("Sepal"))
head(select_ejemplo,5)
```

De igual manera, con *select()*, *ends_with* y *start_with()* podemos seleccionar que inicien o terminen con alguna cadena de texto.

```{r}
select_ejemplo<-iris %>% select(starts_with("Sepal"),ends_with("Length"))
head(select_ejemplo,5)
```


Funciones útiles para *select()*:

- *contains()*: Selecciona variables cuyo nombre contiene la cadena de texto.

- *ends_with()*: Selecciona variables cuyo nombre termina con la cadena de caracteres.

- *everything()*: Selecciona todas las columnas.

- *matches()*: Selecciona las variables cuyos nombres coinciden con una expresión regular.

- *num_range()*: Selecciona las variables por posición.

- *start_with()*: Selecciona variables cuyos nombres empiezan con la cadena de caracteres.

- *any_of*: Selecciona cualquiera de estas variables, en caso de existir


### filter()

La función filter nos permite filtrar filas según una condición, primero notemos que la variable *Species* tiene tres categorías.

```{r}
table(iris$Species)
```

Ahora usaremos la función *filter* para quedarnos solo con las observaciones de la especie virginica.

```{r}
ejemplo_filter<- iris %>% filter(Species=="virginica")
head(ejemplo_filter,5)
```


También se puede usar para filtrar variables numéricas:

```{r}
ejemplo_filter<- iris %>% filter(Sepal.Length>5 & Sepal.Width>=3.5)
head(ejemplo_filter,5)
```

Notemos que en el ejemplo anterior usamos *&*, que nos ayuda a filtrar por dos condiciones.

También podemos usar *|* para filtrar por alguna de las dos condiciones.

```{r}
ejemplo_filter<- iris %>% filter(Sepal.Length>5 | Sepal.Width>=3.5)
head(ejemplo_filter,5)
```


Las condiciones pueden ser expresiones lógicas construidas mediante los operadores relacionales y lógicos: 

- **<** : Menor que

- **>** : Mayor que

- **=** : Igual que

- **<=** : Menor o igual que

- **>=** : Mayor o igual que

- **!=** : Diferente que

- **%in%** : Pertenece al conjunto

- **is.na** : Es NA

- **!is.na** : No es NA


###  arrange()

La función arrange() se utiliza para ordenar las filas de un data frame de acuerdo a una o varias variables. 

Por defecto arrange() ordena las filas por orden ascendente: 

```{r}
ejemplo_arrange<- iris %>% arrange(Sepal.Length)
head(ejemplo_arrange,10)
```

<br>
<br>
Si las queremos ordenar de forma ascendente lo haremos del siguiente modo: 

```{r}
ejemplo_arrange<- iris %>% arrange(desc(Sepal.Length))
head(ejemplo_arrange,10)
```


###  mutate()

Con la función mutate() podemos computar tranformaciones de variables en un data frame. A menudo, tendremos la necesidad de crear nuevas variables que se calculan a partir de variables existentes,mutate() nos proporciona una interface clara para realizar este tipo de operaciones. 

Por ejemplo haremos la suma de las variables *Sepal.Lenght* y *Sepal.Width*:

```{r}
ejemplo_mutate<- iris %>% select(Sepal.Length,Sepal.Width) %>%
  mutate(Suma=Sepal.Length+Sepal.Width)
head(ejemplo_mutate,5)
```

Notemos que en el ejemplo anterior usamos dos *pipes* (%>%), como habiamos mencionado se pueden usar los necesarios para combinar funciones. 



### summarise()

La función summarise() funciona de forma análoga a la función mutate, excepto que en lugar de añadir nuevas columnas crea un nuevo data frame.

Podemos usar el ejemplo anterior y calcular la media de la varible creada *Suma*:

```{r}
ejemplo_summarise<- iris %>% select(Sepal.Length,Sepal.Width) %>%
  mutate(Suma=Sepal.Length+Sepal.Width) %>%
  summarise(Media_Suma=mean(Suma))
ejemplo_summarise
```

Solo fue necesario agregar un *pipe*, especificar el nombre de la varible creada y la operación a realizar.



A continuación se muestran funciones que trabajando conjuntamente con la función summarise() facilitarán nuestro trabajo diario. Las primeras pertenecen al paquete base y las otras son del paquete dplyr. Todas ellas toman como argumento un vector y devuelven un único resultado:

- *min(), max()* : Valores max y min.

- *mean()* : Media.

- *median()* : Mediana.

- *sum()* : Suma de los valores.

- *var(), sd()* : Varianza y desviación estandar.

- *first()* : Primer valor en un vector.

- *last()* : El último valor en un vector

- *n()* : El número de valores en un vector.

- *n_distinc()* : El número de valores distintos en un vector.

- *nth()* : Extrar el valor que ocupa la posición n en un vector.


Mas adelante veremos como combinar esta función con la función *group_by*.


### group_by()

La función group_by() agrupa un conjunto de filas seleccionado en un conjunto de filas de resumen de acuerdo con los valores de una o más columnas o expresiones.

Usaremos el ejemplo anterior, primero creamos nuestra nueva variable *Suma*, despues agrupamos por especie y al final sacamos la media de la variable *Suma* pero esta vez, por la función *group_by*, nos regresara una media por cada grupo creado, es decir, nos regresara el promedio de la suma por especie.

```{r,warning=FALSE,message=FALSE}
ejemplo_groupby<- iris %>%
  mutate(Suma=Sepal.Length+Sepal.Width) %>%
  group_by(Species) %>%
  summarise(Media_Suma=mean(Suma))

ejemplo_groupby
```

### rowwise()

Esta función permite calcular nuevas variables *un renglón a la vez*

```{r}
iris %>% 
  rowwise() %>% 
  mutate(suma = Sepal.Length + Sepal.Width + Petal.Length + Petal.Width) %>% 
  ungroup()

iris %>% 
  rowwise() %>% 
  mutate(suma = sum(across(Sepal.Length:Petal.Width))) %>% 
  ungroup()
```


